#include <stdio.h>
#include <stdlib.h>

int main()
{
	char* p1 = (char*)malloc(2);
	int* p2 = (int*)malloc(8);

	p1[0] = 'A';		// 배열 형태
	p1[1] = 'B';		// 배열 형태

	p2[0] = 10;			// 배열 형태
	p2[1] = 20;			// 배열 형태

	printf("1. 주소\n");
	printf("p1[0] : %x, p1[1] : %x, p2[0] : %x, p2[1] : %x\n", &p1[0], &p1[1], &p2[0], &p2[1]);		// 변수끼리 비슷한 위치에 할당이 된 것을 알 수 있다.

	printf("\n");

	printf("2. 값\n");
	printf("p1[0] : %d, p1[1] : %d, p2[0] : %d, p2[1] : %d\n", p1[0], p1[1], p2[0], p2[1]);

	free(p1);
	p1 = NULL;

	free(p2);
	p2 = NULL;
}
// 9 ~ 13번째 줄
// 동적 할당을 한 p1, p2는 배열형태로 접근이 가능하다.
// 여기서 배열의 단점을 보완할 방법이 동적 할당이라는 것을 알 수 있다.

// 배열의 단점
// 1. 저장할 데이터가 적으면 메모리 낭비가 발생한다.
// 2. 저장할 데이터가 많으면 메모리 부족이 발생한다.
// 3. 배열은 상수로 선언한 뒤 사용이 가능하다. 한번 선언한 배열은 크기를 바꿀 수 없다.

// 필요한 메모리 공간이 얼마인지 예측할 수 없기 때문에 발생한 문제들
// 동적 할당은 프로그래머가 필요한 메모리 크기를 직접 할당하므로써 이런 문제가 없다.
// 또한 포인터로 접근하기 때문에 퍼포먼스 향상에 기여가 큰 것.
// 구조체를 동적 할당하여 속도를 높이자.

// 16번째 줄
// 연속적으로 메모리 공간이 할당됨을 알 수 있다.
// 이로써 배열처럼 접근이 가능함을 알 수 있다.